<?php
/**
 * Automated Security Scanner
 * 
 * @package MoneyQuiz\Security\Scanner
 * @version 1.0.0
 */

namespace MoneyQuiz\Security\Scanner;

/**
 * Automated Scanner
 */
class AutomatedScanner {
    
    private $scan_results = [];
    private $scan_start_time;
    
    /**
     * Run comprehensive security scan
     */
    public function runFullScan() {
        $this->scan_start_time = microtime(true);
        
        $results = [
            'scan_id' => $this->generateScanId(),
            'timestamp' => current_time('mysql'),
            'checks' => [
                'sql_injection' => $this->scanSqlInjection(),
                'xss' => $this->scanXss(),
                'file_inclusion' => $this->scanFileInclusion(),
                'directory_traversal' => $this->scanDirectoryTraversal(),
                'code_injection' => $this->scanCodeInjection(),
                'sensitive_data' => $this->scanSensitiveData(),
                'weak_passwords' => $this->scanWeakPasswords(),
                'outdated_software' => $this->scanOutdatedSoftware()
            ],
            'scan_duration' => microtime(true) - $this->scan_start_time
        ];
        
        $results['summary'] = $this->generateScanSummary($results['checks']);
        
        // Store scan results
        $this->storeScanResults($results);
        
        return $results;
    }
    
    /**
     * Scan for SQL injection vulnerabilities
     */
    private function scanSqlInjection() {
        $vulnerabilities = [];
        
        // Check GET/POST parameters handling
        $vulnerable_patterns = [
            '/\$_GET\[[\'"].*[\'"]\].*\bmysql_query\b/i',
            '/\$_POST\[[\'"].*[\'"]\].*\bmysql_query\b/i',
            '/\$wpdb->query\s*\(\s*["\'].*\$_(GET|POST)/i',
            '/\$wpdb->get_results\s*\(\s*["\'].*\$_(GET|POST)/i'
        ];
        
        $files = $this->getPhpFiles();
        foreach ($files as $file) {
            $content = file_get_contents($file);
            
            foreach ($vulnerable_patterns as $pattern) {
                if (preg_match($pattern, $content, $matches)) {
                    $vulnerabilities[] = [
                        'file' => str_replace(ABSPATH, '', $file),
                        'pattern' => $pattern,
                        'severity' => 'high',
                        'description' => 'Potential SQL injection vulnerability'
                    ];
                }
            }
        }
        
        return [
            'passed' => empty($vulnerabilities),
            'vulnerabilities' => $vulnerabilities
        ];
    }
    
    /**
     * Scan for XSS vulnerabilities
     */
    private function scanXss() {
        $vulnerabilities = [];
        
        // Check for unescaped output
        $vulnerable_patterns = [
            '/echo\s+\$_(GET|POST|REQUEST)\[/i',
            '/print\s+\$_(GET|POST|REQUEST)\[/i',
            '/\<\?=\s*\$_(GET|POST|REQUEST)\[/i'
        ];
        
        $files = $this->getPhpFiles();
        foreach ($files as $file) {
            $content = file_get_contents($file);
            
            foreach ($vulnerable_patterns as $pattern) {
                if (preg_match_all($pattern, $content, $matches, PREG_OFFSET_CAPTURE)) {
                    foreach ($matches[0] as $match) {
                        $line = $this->getLineNumber($content, $match[1]);
                        $vulnerabilities[] = [
                            'file' => str_replace(ABSPATH, '', $file),
                            'line' => $line,
                            'severity' => 'high',
                            'description' => 'Unescaped user input output'
                        ];
                    }
                }
            }
        }
        
        return [
            'passed' => empty($vulnerabilities),
            'vulnerabilities' => $vulnerabilities
        ];
    }
    
    /**
     * Scan for file inclusion vulnerabilities
     */
    private function scanFileInclusion() {
        $vulnerabilities = [];
        
        $vulnerable_patterns = [
            '/include\s*\(\s*\$_(GET|POST|REQUEST)\[/i',
            '/include_once\s*\(\s*\$_(GET|POST|REQUEST)\[/i',
            '/require\s*\(\s*\$_(GET|POST|REQUEST)\[/i',
            '/require_once\s*\(\s*\$_(GET|POST|REQUEST)\[/i'
        ];
        
        $files = $this->getPhpFiles();
        foreach ($files as $file) {
            $content = file_get_contents($file);
            
            foreach ($vulnerable_patterns as $pattern) {
                if (preg_match($pattern, $content)) {
                    $vulnerabilities[] = [
                        'file' => str_replace(ABSPATH, '', $file),
                        'severity' => 'critical',
                        'description' => 'File inclusion with user input'
                    ];
                }
            }
        }
        
        return [
            'passed' => empty($vulnerabilities),
            'vulnerabilities' => $vulnerabilities
        ];
    }
    
    /**
     * Scan for directory traversal
     */
    private function scanDirectoryTraversal() {
        $vulnerabilities = [];
        
        $vulnerable_patterns = [
            '/file_get_contents\s*\(\s*["\']?\s*\$_(GET|POST|REQUEST)/i',
            '/fopen\s*\(\s*["\']?\s*\$_(GET|POST|REQUEST)/i',
            '/readfile\s*\(\s*["\']?\s*\$_(GET|POST|REQUEST)/i'
        ];
        
        $files = $this->getPhpFiles();
        foreach ($files as $file) {
            $content = file_get_contents($file);
            
            foreach ($vulnerable_patterns as $pattern) {
                if (preg_match($pattern, $content)) {
                    $vulnerabilities[] = [
                        'file' => str_replace(ABSPATH, '', $file),
                        'severity' => 'high',
                        'description' => 'Potential directory traversal'
                    ];
                }
            }
        }
        
        return [
            'passed' => empty($vulnerabilities),
            'vulnerabilities' => $vulnerabilities
        ];
    }
    
    /**
     * Scan for code injection
     */
    private function scanCodeInjection() {
        $vulnerabilities = [];
        
        $dangerous_functions = [
            'eval', 'assert', 'create_function',
            'system', 'exec', 'shell_exec', 'passthru',
            'preg_replace.*\/e'
        ];
        
        $files = $this->getPhpFiles();
        foreach ($files as $file) {
            $content = file_get_contents($file);
            
            foreach ($dangerous_functions as $func) {
                $pattern = '/\b' . $func . '\s*\(/i';
                if (preg_match($pattern, $content)) {
                    $vulnerabilities[] = [
                        'file' => str_replace(ABSPATH, '', $file),
                        'function' => $func,
                        'severity' => 'high',
                        'description' => "Use of dangerous function: {$func}"
                    ];
                }
            }
        }
        
        return [
            'passed' => empty($vulnerabilities),
            'vulnerabilities' => $vulnerabilities
        ];
    }
    
    /**
     * Scan for sensitive data exposure
     */
    private function scanSensitiveData() {
        $issues = [];
        
        // Check for hardcoded credentials
        $patterns = [
            '/(?:password|passwd|pwd)\s*=\s*["\'][^"\']+["\']/i',
            '/(?:api_key|apikey)\s*=\s*["\'][^"\']+["\']/i',
            '/(?:secret|token)\s*=\s*["\'][^"\']+["\']/i'
        ];
        
        $files = $this->getPhpFiles();
        foreach ($files as $file) {
            $content = file_get_contents($file);
            
            foreach ($patterns as $pattern) {
                if (preg_match($pattern, $content, $matches)) {
                    // Skip if it's a placeholder
                    if (!preg_match('/\{\{|%%|xxx|your[_-]?|example/i', $matches[0])) {
                        $issues[] = [
                            'file' => str_replace(ABSPATH, '', $file),
                            'severity' => 'high',
                            'description' => 'Possible hardcoded credentials'
                        ];
                    }
                }
            }
        }
        
        return [
            'passed' => empty($issues),
            'issues' => $issues
        ];
    }
    
    /**
     * Scan for weak passwords
     */
    private function scanWeakPasswords() {
        global $wpdb;
        $weak_users = [];
        
        // Get admin users
        $admins = get_users(['role' => 'administrator']);
        
        foreach ($admins as $admin) {
            // Check for common usernames
            if (in_array(strtolower($admin->user_login), ['admin', 'administrator', 'root', 'test'])) {
                $weak_users[] = [
                    'user_id' => $admin->ID,
                    'username' => $admin->user_login,
                    'issue' => 'Common username',
                    'severity' => 'medium'
                ];
            }
        }
        
        return [
            'passed' => empty($weak_users),
            'weak_accounts' => $weak_users
        ];
    }
    
    /**
     * Scan for outdated software
     */
    private function scanOutdatedSoftware() {
        $outdated = [];
        
        // Check WordPress version
        global $wp_version;
        $latest_version = $this->getLatestWordPressVersion();
        
        if ($latest_version && version_compare($wp_version, $latest_version, '<')) {
            $outdated[] = [
                'component' => 'WordPress Core',
                'current' => $wp_version,
                'latest' => $latest_version,
                'severity' => 'high'
            ];
        }
        
        return [
            'passed' => empty($outdated),
            'outdated_components' => $outdated
        ];
    }
    
    /**
     * Get PHP files to scan
     */
    private function getPhpFiles() {
        $plugin_dir = plugin_dir_path(dirname(__FILE__, 2));
        $files = [];
        
        $iterator = new \RecursiveIteratorIterator(
            new \RecursiveDirectoryIterator($plugin_dir)
        );
        
        foreach ($iterator as $file) {
            if ($file->isFile() && $file->getExtension() === 'php') {
                $files[] = $file->getPathname();
            }
        }
        
        return $files;
    }
    
    /**
     * Get line number from offset
     */
    private function getLineNumber($content, $offset) {
        return substr_count(substr($content, 0, $offset), "\n") + 1;
    }
    
    /**
     * Generate scan ID
     */
    private function generateScanId() {
        return 'scan_' . date('YmdHis') . '_' . wp_generate_password(8, false);
    }
    
    /**
     * Store scan results
     */
    private function storeScanResults($results) {
        update_option('money_quiz_last_security_scan', $results);
    }
    
    /**
     * Generate scan summary
     */
    private function generateScanSummary($checks) {
        $total_issues = 0;
        $failed_checks = 0;
        
        foreach ($checks as $check => $result) {
            if (!$result['passed']) {
                $failed_checks++;
                if (isset($result['vulnerabilities'])) {
                    $total_issues += count($result['vulnerabilities']);
                }
            }
        }
        
        return [
            'total_checks' => count($checks),
            'passed_checks' => count($checks) - $failed_checks,
            'failed_checks' => $failed_checks,
            'total_issues' => $total_issues,
            'security_score' => round(((count($checks) - $failed_checks) / count($checks)) * 100)
        ];
    }
    
    /**
     * Get latest WordPress version
     */
    private function getLatestWordPressVersion() {
        $version_data = get_site_transient('update_core');
        
        if ($version_data && isset($version_data->updates[0])) {
            return $version_data->updates[0]->current;
        }
        
        return null;
    }
}