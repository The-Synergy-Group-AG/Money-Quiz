<?php
/**
 * CSS-in-JS Runtime Style Optimization
 * Optimizes dynamic styles generated by CSS-in-JS libraries
 */

class CSSInJSOptimizer {
    private $config = [
        'extract_static_styles' => true,
        'enable_atomic_css' => true,
        'deduplicate_styles' => true,
        'cache_compiled_styles' => true,
        'minify_runtime_styles' => true,
        'style_injection_strategy' => 'head', // head, body, or lazy
        'atomic_class_prefix' => '_',
        'hash_length' => 6,
        'ssr_optimization' => true
    ];
    
    private $performance_monitor;
    private $style_cache = [];
    private $atomic_classes = [];
    private $runtime_styles = [];
    private $compiled_cache_dir = '/tmp/css-in-js-cache/';
    
    public function __construct() {
        $this->performance_monitor = new PerformanceMonitor();
        if (!is_dir($this->compiled_cache_dir)) {
            mkdir($this->compiled_cache_dir, 0777, true);
        }
    }
    
    /**
     * Optimize CSS-in-JS styles
     */
    public function optimizeStyles($styles, $context = []) {
        $startTime = microtime(true);
        
        // Check cache first
        $cacheKey = $this->generateCacheKey($styles, $context);
        if ($this->config['cache_compiled_styles'] && isset($this->style_cache[$cacheKey])) {
            return $this->style_cache[$cacheKey];
        }
        
        $optimized = $styles;
        
        // Extract static styles
        if ($this->config['extract_static_styles']) {
            $optimized = $this->extractStaticStyles($optimized);
        }
        
        // Convert to atomic CSS
        if ($this->config['enable_atomic_css']) {
            $optimized = $this->convertToAtomicCSS($optimized);
        }
        
        // Deduplicate styles
        if ($this->config['deduplicate_styles']) {
            $optimized = $this->deduplicateStyles($optimized);
        }
        
        // Minify runtime styles
        if ($this->config['minify_runtime_styles']) {
            $optimized = $this->minifyStyles($optimized);
        }
        
        $result = [
            'styles' => $optimized,
            'classes' => $this->generateOptimizedClasses($optimized),
            'runtime' => $this->runtime_styles,
            'atomic' => $this->atomic_classes,
            'optimization_time' => microtime(true) - $startTime
        ];
        
        // Cache result
        if ($this->config['cache_compiled_styles']) {
            $this->style_cache[$cacheKey] = $result;
            $this->persistCache($cacheKey, $result);
        }
        
        $this->performance_monitor->recordMetric('css_in_js_optimization', [
            'original_size' => strlen(json_encode($styles)),
            'optimized_size' => strlen(json_encode($result)),
            'atomic_classes' => count($this->atomic_classes),
            'cache_hit' => false
        ]);
        
        return $result;
    }
    
    /**
     * Extract static styles that don't change
     */
    private function extractStaticStyles($styles) {
        $static = [];
        $dynamic = [];
        
        foreach ($styles as $selector => $rules) {
            $isStatic = true;
            $staticRules = [];
            $dynamicRules = [];
            
            foreach ($rules as $property => $value) {
                if ($this->isDynamicValue($value)) {
                    $isStatic = false;
                    $dynamicRules[$property] = $value;
                } else {
                    $staticRules[$property] = $value;
                }
            }
            
            if ($isStatic) {
                $static[$selector] = $rules;
            } else {
                if (!empty($staticRules)) {
                    $static[$selector . '-static'] = $staticRules;
                }
                if (!empty($dynamicRules)) {
                    $dynamic[$selector] = $dynamicRules;
                }
            }
        }
        
        // Save static styles for extraction
        if (!empty($static)) {
            $this->saveStaticStyles($static);
        }
        
        return $dynamic;
    }
    
    /**
     * Check if a value is dynamic
     */
    private function isDynamicValue($value) {
        // Check for function calls, variables, or expressions
        if (is_callable($value) || is_object($value)) {
            return true;
        }
        
        if (is_string($value)) {
            // Check for template literals or expressions
            return preg_match('/\$\{|var\(|calc\(/', $value) || 
                   strpos($value, 'props.') !== false ||
                   strpos($value, 'theme.') !== false;
        }
        
        return false;
    }
    
    /**
     * Convert styles to atomic CSS
     */
    private function convertToAtomicCSS($styles) {
        $atomicStyles = [];
        
        foreach ($styles as $selector => $rules) {
            $atomicClasses = [];
            
            foreach ($rules as $property => $value) {
                $atomicClass = $this->generateAtomicClass($property, $value);
                
                if (!isset($this->atomic_classes[$atomicClass])) {
                    $this->atomic_classes[$atomicClass] = [
                        'property' => $property,
                        'value' => $value,
                        'usage_count' => 0
                    ];
                }
                
                $this->atomic_classes[$atomicClass]['usage_count']++;
                $atomicClasses[] = $atomicClass;
            }
            
            $atomicStyles[$selector] = $atomicClasses;
        }
        
        return $atomicStyles;
    }
    
    /**
     * Generate atomic class name
     */
    private function generateAtomicClass($property, $value) {
        // Create a unique, short class name
        $hash = substr(md5($property . ':' . $value), 0, $this->config['hash_length']);
        
        // Use abbreviated property names
        $propAbbr = $this->getPropertyAbbreviation($property);
        
        return $this->config['atomic_class_prefix'] . $propAbbr . $hash;
    }
    
    /**
     * Get property abbreviation for atomic classes
     */
    private function getPropertyAbbreviation($property) {
        $abbreviations = [
            'background' => 'bg',
            'background-color' => 'bgc',
            'color' => 'c',
            'display' => 'd',
            'flex' => 'f',
            'font-size' => 'fs',
            'font-weight' => 'fw',
            'height' => 'h',
            'margin' => 'm',
            'margin-top' => 'mt',
            'margin-right' => 'mr',
            'margin-bottom' => 'mb',
            'margin-left' => 'ml',
            'padding' => 'p',
            'padding-top' => 'pt',
            'padding-right' => 'pr',
            'padding-bottom' => 'pb',
            'padding-left' => 'pl',
            'position' => 'pos',
            'text-align' => 'ta',
            'width' => 'w',
            'z-index' => 'z'
        ];
        
        return $abbreviations[$property] ?? substr($property, 0, 3);
    }
    
    /**
     * Deduplicate styles across components
     */
    private function deduplicateStyles($styles) {
        $uniqueStyles = [];
        $styleMap = [];
        
        foreach ($styles as $selector => $rules) {
            $styleHash = $this->hashStyle($rules);
            
            if (!isset($styleMap[$styleHash])) {
                $styleMap[$styleHash] = $selector;
                $uniqueStyles[$selector] = $rules;
            } else {
                // Map duplicate to original
                $uniqueStyles[$selector] = ['@extends' => $styleMap[$styleHash]];
            }
        }
        
        return $uniqueStyles;
    }
    
    /**
     * Hash style object for deduplication
     */
    private function hashStyle($style) {
        if (is_array($style)) {
            ksort($style);
            return md5(json_encode($style));
        }
        return md5($style);
    }
    
    /**
     * Minify styles
     */
    private function minifyStyles($styles) {
        if (is_string($styles)) {
            // Remove comments
            $styles = preg_replace('/\/\*[^*]*\*+([^\/*][^*]*\*+)*\//', '', $styles);
            // Remove unnecessary whitespace
            $styles = preg_replace('/\s+/', ' ', $styles);
            $styles = preg_replace('/\s*([{}:;,])\s*/', '$1', $styles);
            return trim($styles);
        }
        
        if (is_array($styles)) {
            return array_map([$this, 'minifyStyles'], $styles);
        }
        
        return $styles;
    }
    
    /**
     * Generate optimized class names
     */
    private function generateOptimizedClasses($styles) {
        $classes = [];
        
        foreach ($styles as $selector => $atomicClasses) {
            if (is_array($atomicClasses)) {
                $classes[$selector] = implode(' ', $atomicClasses);
            } else {
                $classes[$selector] = $this->generateClassName($selector);
            }
        }
        
        return $classes;
    }
    
    /**
     * Generate short, unique class name
     */
    private function generateClassName($selector) {
        return $this->config['atomic_class_prefix'] . substr(md5($selector), 0, $this->config['hash_length']);
    }
    
    /**
     * Generate cache key
     */
    private function generateCacheKey($styles, $context) {
        return md5(json_encode($styles) . json_encode($context));
    }
    
    /**
     * Save static styles for extraction
     */
    private function saveStaticStyles($styles) {
        $css = $this->stylesToCSS($styles);
        $filename = 'static-' . md5($css) . '.css';
        $filepath = $this->compiled_cache_dir . $filename;
        
        if (!file_exists($filepath)) {
            file_put_contents($filepath, $css);
        }
        
        $this->runtime_styles['static_files'][] = $filename;
    }
    
    /**
     * Convert styles array to CSS string
     */
    private function stylesToCSS($styles) {
        $css = '';
        
        foreach ($styles as $selector => $rules) {
            $css .= $selector . ' {';
            
            if (is_array($rules)) {
                foreach ($rules as $property => $value) {
                    $css .= $property . ':' . $value . ';';
                }
            }
            
            $css .= '}';
        }
        
        return $this->minifyStyles($css);
    }
    
    /**
     * Persist cache to disk
     */
    private function persistCache($key, $data) {
        $filepath = $this->compiled_cache_dir . $key . '.json';
        file_put_contents($filepath, json_encode($data));
    }
    
    /**
     * Generate runtime injection script
     */
    public function generateRuntimeInjector() {
        return '
// CSS-in-JS Runtime Injector
const CSSInJSRuntime = (() => {
    const styleCache = new Map();
    const styleSheet = document.createElement("style");
    const atomicStyles = new Map();
    let injectionTarget = document.head;
    
    // Initialize
    if (document.head) {
        document.head.appendChild(styleSheet);
    } else {
        document.addEventListener("DOMContentLoaded", () => {
            document.head.appendChild(styleSheet);
        });
    }
    
    // Inject styles
    const inject = (id, styles) => {
        if (styleCache.has(id)) {
            return styleCache.get(id);
        }
        
        const css = typeof styles === "string" ? styles : stylesToCSS(styles);
        const rule = styleSheet.sheet.insertRule(css, styleSheet.sheet.cssRules.length);
        
        styleCache.set(id, {
            css,
            rule,
            refs: 1
        });
        
        return styleCache.get(id);
    };
    
    // Convert style object to CSS
    const stylesToCSS = (styles) => {
        let css = "";
        
        for (const [selector, rules] of Object.entries(styles)) {
            css += `${selector}{`;
            
            for (const [prop, value] of Object.entries(rules)) {
                css += `${prop}:${value};`;
            }
            
            css += "}";
        }
        
        return css;
    };
    
    // Inject atomic styles
    const injectAtomic = (prop, value) => {
        const key = `${prop}:${value}`;
        
        if (atomicStyles.has(key)) {
            return atomicStyles.get(key);
        }
        
        const className = generateAtomicClass(prop, value);
        const css = `.${className}{${prop}:${value}}`;
        
        inject(className, css);
        atomicStyles.set(key, className);
        
        return className;
    };
    
    // Generate atomic class name
    const generateAtomicClass = (prop, value) => {
        const hash = simpleHash(`${prop}:${value}`);
        const abbr = propAbbreviations[prop] || prop.substr(0, 3);
        return `_${abbr}${hash}`;
    };
    
    // Simple hash function
    const simpleHash = (str) => {
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            hash = ((hash << 5) - hash) + str.charCodeAt(i);
            hash = hash & hash;
        }
        return Math.abs(hash).toString(36).substr(0, 6);
    };
    
    // Property abbreviations
    const propAbbreviations = {
        "background": "bg",
        "background-color": "bgc",
        "color": "c",
        "display": "d",
        "font-size": "fs",
        "margin": "m",
        "padding": "p",
        "width": "w",
        "height": "h"
    };
    
    // Remove styles
    const remove = (id) => {
        const cached = styleCache.get(id);
        if (!cached) return;
        
        cached.refs--;
        
        if (cached.refs === 0) {
            styleSheet.sheet.deleteRule(cached.rule);
            styleCache.delete(id);
        }
    };
    
    // Extract critical styles
    const extractCritical = () => {
        const critical = [];
        
        for (const [id, data] of styleCache.entries()) {
            critical.push(data.css);
        }
        
        return critical.join("");
    };
    
    return {
        inject,
        injectAtomic,
        remove,
        extractCritical,
        getCache: () => styleCache,
        getAtomicStyles: () => atomicStyles
    };
})();

// Export for use
if (typeof module !== "undefined") {
    module.exports = CSSInJSRuntime;
}
';
    }
    
    /**
     * Generate SSR optimization helper
     */
    public function generateSSRHelper() {
        return '
// SSR CSS Collection Helper
class SSRStyleCollector {
    constructor() {
        this.styles = [];
        this.atomicClasses = new Set();
        this.criticalStyles = [];
    }
    
    collect(componentId, styles) {
        this.styles.push({
            id: componentId,
            styles: styles,
            critical: this.isCritical(componentId)
        });
        
        // Extract atomic classes
        if (styles.atomic) {
            styles.atomic.forEach(cls => this.atomicClasses.add(cls));
        }
    }
    
    isCritical(componentId) {
        // Determine if component is critical for SSR
        const criticalComponents = [
            "Header",
            "Navigation",
            "Hero",
            "AboveFold"
        ];
        
        return criticalComponents.some(comp => 
            componentId.includes(comp)
        );
    }
    
    generateStyleTags() {
        const critical = [];
        const nonCritical = [];
        
        this.styles.forEach(({ id, styles, critical: isCrit }) => {
            const css = this.stylesToCSS(styles);
            
            if (isCrit) {
                critical.push(css);
            } else {
                nonCritical.push(css);
            }
        });
        
        return {
            critical: `<style id="ssr-critical">${critical.join("")}</style>`,
            nonCritical: `<style id="ssr-non-critical">${nonCritical.join("")}</style>`,
            atomic: this.generateAtomicCSS()
        };
    }
    
    generateAtomicCSS() {
        const atomicCSS = Array.from(this.atomicClasses)
            .map(({ className, property, value }) => 
                `.${className}{${property}:${value}}`
            )
            .join("");
        
        return `<style id="atomic-css">${atomicCSS}</style>`;
    }
    
    stylesToCSS(styles) {
        // Convert style object to CSS string
        if (typeof styles === "string") return styles;
        
        let css = "";
        for (const [selector, rules] of Object.entries(styles)) {
            css += `${selector}{`;
            for (const [prop, value] of Object.entries(rules)) {
                css += `${prop}:${value};`;
            }
            css += "}";
        }
        return css;
    }
    
    // Generate hydration script
    generateHydrationScript() {
        return `
            <script>
                // Hydrate CSS-in-JS styles
                window.__SSR_STYLES__ = ${JSON.stringify(this.styles)};
                window.__ATOMIC_CLASSES__ = ${JSON.stringify([...this.atomicClasses])};
                
                // Remove SSR styles after hydration
                if (window.requestIdleCallback) {
                    requestIdleCallback(() => {
                        document.getElementById("ssr-critical")?.remove();
                        document.getElementById("ssr-non-critical")?.remove();
                    });
                } else {
                    setTimeout(() => {
                        document.getElementById("ssr-critical")?.remove();
                        document.getElementById("ssr-non-critical")?.remove();
                    }, 1000);
                }
            </script>
        `;
    }
}

// Export for Node.js SSR
if (typeof module !== "undefined") {
    module.exports = SSRStyleCollector;
}
';
    }
    
    /**
     * Analyze CSS-in-JS usage patterns
     */
    public function analyzeUsagePatterns($componentPath) {
        $content = file_get_contents($componentPath);
        
        $patterns = [
            'styled_components' => '/styled\.\w+`[^`]+`/s',
            'emotion' => '/css`[^`]+`/s',
            'jss' => '/createUseStyles\(\{[^}]+\}\)/s',
            'inline_styles' => '/style=\{\{[^}]+\}\}/s',
            'classnames' => '/className=\{[^}]+\}/s'
        ];
        
        $analysis = [
            'patterns_found' => [],
            'dynamic_styles_count' => 0,
            'static_styles_count' => 0,
            'optimization_opportunities' => []
        ];
        
        foreach ($patterns as $library => $pattern) {
            if (preg_match_all($pattern, $content, $matches)) {
                $analysis['patterns_found'][$library] = count($matches[0]);
                
                // Analyze each match
                foreach ($matches[0] as $match) {
                    if ($this->containsDynamicStyles($match)) {
                        $analysis['dynamic_styles_count']++;
                    } else {
                        $analysis['static_styles_count']++;
                        $analysis['optimization_opportunities'][] = [
                            'type' => 'extract_static',
                            'library' => $library,
                            'code' => substr($match, 0, 100) . '...'
                        ];
                    }
                }
            }
        }
        
        return $analysis;
    }
    
    /**
     * Check if code contains dynamic styles
     */
    private function containsDynamicStyles($code) {
        $dynamicPatterns = [
            '/\$\{[^}]+\}/', // Template literals
            '/props\.[\w.]+/', // Props access
            '/theme\.[\w.]+/', // Theme access
            '/\? [^:]+:/', // Ternary operators
        ];
        
        foreach ($dynamicPatterns as $pattern) {
            if (preg_match($pattern, $code)) {
                return true;
            }
        }
        
        return false;
    }
}

// Example usage
$optimizer = new CSSInJSOptimizer();

// Optimize styles
$styles = [
    '.button' => [
        'background-color' => '#007bff',
        'color' => 'white',
        'padding' => '10px 20px',
        'border-radius' => '4px',
        'font-size' => '16px'
    ],
    '.button:hover' => [
        'background-color' => '#0056b3'
    ],
    '.card' => [
        'background-color' => 'white',
        'padding' => '20px',
        'border-radius' => '8px',
        'box-shadow' => '0 2px 4px rgba(0,0,0,0.1)'
    ]
];

$result = $optimizer->optimizeStyles($styles);

echo "CSS-in-JS Optimization Results:\n";
echo "Atomic Classes Generated: " . count($result['atomic']) . "\n";
echo "Optimization Time: " . round($result['optimization_time'] * 1000, 2) . "ms\n";

// Generate runtime scripts
file_put_contents('css-in-js-runtime.js', $optimizer->generateRuntimeInjector());
file_put_contents('ssr-style-collector.js', $optimizer->generateSSRHelper());

// Analyze component for patterns
if (file_exists('components/Button.jsx')) {
    $analysis = $optimizer->analyzeUsagePatterns('components/Button.jsx');
    
    echo "\nCSS-in-JS Pattern Analysis:\n";
    foreach ($analysis['patterns_found'] as $library => $count) {
        echo "$library: $count instances\n";
    }
    echo "Static styles: {$analysis['static_styles_count']}\n";
    echo "Dynamic styles: {$analysis['dynamic_styles_count']}\n";
    echo "Optimization opportunities: " . count($analysis['optimization_opportunities']) . "\n";
}
